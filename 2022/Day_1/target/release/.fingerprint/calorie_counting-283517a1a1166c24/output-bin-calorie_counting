{"message":"type annotations needed","code":{"code":"E0283","explanation":"An implementation cannot be chosen unambiguously because of lack of information.\n\nErroneous code example:\n\n```compile_fail,E0283\nstruct Foo;\n\nimpl Into<u32> for Foo {\n    fn into(self) -> u32 { 1 }\n}\n\nlet foo = Foo;\nlet bar: u32 = foo.into() * 1u32;\n```\n\nThis error can be solved by adding type annotations that provide the missing\ninformation to the compiler. In this case, the solution is to specify the\ntrait's type parameter:\n\n```\nstruct Foo;\n\nimpl Into<u32> for Foo {\n    fn into(self) -> u32 { 1 }\n}\n\nlet foo = Foo;\nlet bar: u32 = Into::<u32>::into(foo) * 1u32;\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":482,"byte_end":488,"line_start":17,"line_end":17,"column_start":26,"column_end":32,"is_primary":true,"text":[{"text":"    let three:&str = one.as_ref() + two.as_ref();","highlight_start":26,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"multiple `impl`s satisfying `String: AsRef<_>` found in the following crates: `alloc`, `std`:\n- impl AsRef<OsStr> for String;\n- impl AsRef<Path> for String;\n- impl AsRef<[u8]> for String;\n- impl AsRef<str> for String;","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"try using a fully qualified path to specify the expected types","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":478,"byte_end":478,"line_start":17,"line_end":17,"column_start":22,"column_end":22,"is_primary":true,"text":[{"text":"    let three:&str = one.as_ref() + two.as_ref();","highlight_start":22,"highlight_end":22}],"label":null,"suggested_replacement":"<String as AsRef<T>>::as_ref(&","suggestion_applicability":"HasPlaceholders","expansion":null},{"file_name":"src/main.rs","byte_start":481,"byte_end":490,"line_start":17,"line_end":17,"column_start":25,"column_end":34,"is_primary":true,"text":[{"text":"    let three:&str = one.as_ref() + two.as_ref();","highlight_start":25,"highlight_end":34}],"label":null,"suggested_replacement":")","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0283]\u001b[0m\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:17:26\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m17\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let three:&str = one.as_ref() + two.as_ref();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: multiple `impl`s satisfying `String: AsRef<_>` found in the following crates: `alloc`, `std`:\u001b[0m\n\u001b[0m           - impl AsRef<OsStr> for String;\u001b[0m\n\u001b[0m           - impl AsRef<Path> for String;\u001b[0m\n\u001b[0m           - impl AsRef<[u8]> for String;\u001b[0m\n\u001b[0m           - impl AsRef<str> for String;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: try using a fully qualified path to specify the expected types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m17\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let three:&str = \u001b[0m\u001b[0m\u001b[38;5;10m<String as AsRef<T>>::as_ref(&\u001b[0m\u001b[0mone\u001b[0m\u001b[0m\u001b[38;5;10m)\u001b[0m\u001b[0m + two.as_ref();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[38;5;10m++++++++++++++++++++++++++++++\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[38;5;10m~\u001b[0m\n\n"}
{"message":"type annotations needed","code":{"code":"E0283","explanation":"An implementation cannot be chosen unambiguously because of lack of information.\n\nErroneous code example:\n\n```compile_fail,E0283\nstruct Foo;\n\nimpl Into<u32> for Foo {\n    fn into(self) -> u32 { 1 }\n}\n\nlet foo = Foo;\nlet bar: u32 = foo.into() * 1u32;\n```\n\nThis error can be solved by adding type annotations that provide the missing\ninformation to the compiler. In this case, the solution is to specify the\ntrait's type parameter:\n\n```\nstruct Foo;\n\nimpl Into<u32> for Foo {\n    fn into(self) -> u32 { 1 }\n}\n\nlet foo = Foo;\nlet bar: u32 = Into::<u32>::into(foo) * 1u32;\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":497,"byte_end":503,"line_start":17,"line_end":17,"column_start":41,"column_end":47,"is_primary":true,"text":[{"text":"    let three:&str = one.as_ref() + two.as_ref();","highlight_start":41,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"multiple `impl`s satisfying `String: AsRef<_>` found in the following crates: `alloc`, `std`:\n- impl AsRef<OsStr> for String;\n- impl AsRef<Path> for String;\n- impl AsRef<[u8]> for String;\n- impl AsRef<str> for String;","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"try using a fully qualified path to specify the expected types","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":493,"byte_end":493,"line_start":17,"line_end":17,"column_start":37,"column_end":37,"is_primary":true,"text":[{"text":"    let three:&str = one.as_ref() + two.as_ref();","highlight_start":37,"highlight_end":37}],"label":null,"suggested_replacement":"<String as AsRef<T>>::as_ref(&","suggestion_applicability":"HasPlaceholders","expansion":null},{"file_name":"src/main.rs","byte_start":496,"byte_end":505,"line_start":17,"line_end":17,"column_start":40,"column_end":49,"is_primary":true,"text":[{"text":"    let three:&str = one.as_ref() + two.as_ref();","highlight_start":40,"highlight_end":49}],"label":null,"suggested_replacement":")","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0283]\u001b[0m\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:17:41\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m17\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let three:&str = one.as_ref() + two.as_ref();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: multiple `impl`s satisfying `String: AsRef<_>` found in the following crates: `alloc`, `std`:\u001b[0m\n\u001b[0m           - impl AsRef<OsStr> for String;\u001b[0m\n\u001b[0m           - impl AsRef<Path> for String;\u001b[0m\n\u001b[0m           - impl AsRef<[u8]> for String;\u001b[0m\n\u001b[0m           - impl AsRef<str> for String;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: try using a fully qualified path to specify the expected types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m17\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let three:&str = one.as_ref() + \u001b[0m\u001b[0m\u001b[38;5;10m<String as AsRef<T>>::as_ref(&\u001b[0m\u001b[0mtwo\u001b[0m\u001b[0m\u001b[38;5;10m)\u001b[0m\u001b[0m;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                     \u001b[0m\u001b[0m\u001b[38;5;10m++++++++++++++++++++++++++++++\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[38;5;10m~\u001b[0m\n\n"}
{"message":"aborting due to 2 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 2 previous errors\u001b[0m\n\n"}
{"message":"For more information about this error, try `rustc --explain E0283`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about this error, try `rustc --explain E0283`.\u001b[0m\n"}
